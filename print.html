<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SIMD Programming in Rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mdbook-admonish.css">
        <link rel="stylesheet" href="././mdbook-admonish.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="0-title.html">SIMD Programming in Rust</a></li><li class="chapter-item expanded "><a href="1-intro.html"><strong aria-hidden="true">1.</strong> A quick introduction</a></li><li class="chapter-item expanded "><a href="2-target-features.html"><strong aria-hidden="true">2.</strong> Target Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2.1-rustflags.html"><strong aria-hidden="true">2.1.</strong> Program-wide with RUSTFLAGS</a></li><li class="chapter-item expanded "><a href="2.2-detection.html"><strong aria-hidden="true">2.2.</strong> Runtime detection</a></li><li class="chapter-item expanded "><a href="2.3-multiversion.html"><strong aria-hidden="true">2.3.</strong> The easy way, with multiversion</a></li></ol></li><li class="chapter-item expanded "><a href="3-portable-simd.html"><strong aria-hidden="true">3.</strong> Portable SIMD</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.1-vectors.html"><strong aria-hidden="true">3.1.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="3.2-masks.html"><strong aria-hidden="true">3.2.</strong> Masks</a></li></ol></li><li class="chapter-item expanded "><a href="4-std-arch.html"><strong aria-hidden="true">4.</strong> Explicit SIMD (std::arch)</a></li><li class="chapter-item expanded "><a href="5-tricks.html"><strong aria-hidden="true">5.</strong> Tips and tricks</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SIMD Programming in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="simd-programming-in-rust"><a class="header" href="#simd-programming-in-rust">SIMD Programming in Rust</a></h1>
<p>by Caleb Zulawski</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-quick-introduction-to-simd"><a class="header" href="#a-quick-introduction-to-simd">A quick introduction to SIMD</a></h1>
<p>SIMD is short for <em>single instruction, multiple data</em>.
Consider the following function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_array(a: [f32; 4], b: [f32; 4]) -&gt; [f32; 4] {
    [
        a[0] + b[0],
        a[1] + b[1],
        a[2] + b[2],
        a[3] + b[3],
    ]
}
<span class="boring">}
</span></code></pre></pre>
<p>Without SIMD, each array element is computed separately.  On x86-64, this instruction is <code>addss</code>:</p>
<center>
<pre class="svgbob"><style>text{fill:var(--fg)}</style><svg xmlns="http://www.w3.org/2000/svg" width="296" height="208">
  <style>
    line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}
    <!--separator-->
</style>
  <defs>
    <marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,0 0,4 4,2 0,0"></polygon>
    </marker>
    <marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,2 2,0 4,2 2,4 0,2"></polygon>
    </marker>
    <marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="filled"></circle>
    </marker>
    <marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="bg_filled"></circle>
    </marker>
    <marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="3" class="bg_filled"></circle>
    </marker>
  </defs>
  <rect class="backdrop" x="0" y="0" width="296" height="208"></rect>
  <rect x="52" y="8" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="66" y="28" >a[0]</text>
  <rect x="52" y="56" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="66" y="76" >a[1]</text>
  <rect x="52" y="104" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="66" y="124" >a[2]</text>
  <rect x="52" y="152" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="66" y="172" >a[3]</text>
  <rect x="140" y="8" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="154" y="28" >b[0]</text>
  <rect x="140" y="56" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="154" y="76" >b[1]</text>
  <rect x="140" y="104" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="154" y="124" >b[2]</text>
  <rect x="140" y="152" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="154" y="172" >b[3]</text>
  <rect x="228" y="8" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="242" y="28" >c[0]</text>
  <rect x="228" y="56" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="242" y="76" >c[1]</text>
  <rect x="228" y="104" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="242" y="124" >c[2]</text>
  <rect x="228" y="152" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="242" y="172" >c[3]</text>
  <text x="2" y="28" >addss</text>
  <text x="122" y="28" >+</text>
  <line x1="208" y1="22" x2="216" y2="22" class="solid"></line>
  <line x1="208" y1="26" x2="216" y2="26" class="solid"></line>
  <text x="2" y="76" >addss</text>
  <text x="122" y="76" >+</text>
  <line x1="208" y1="70" x2="216" y2="70" class="solid"></line>
  <line x1="208" y1="74" x2="216" y2="74" class="solid"></line>
  <text x="2" y="124" >addss</text>
  <text x="122" y="124" >+</text>
  <line x1="208" y1="118" x2="216" y2="118" class="solid"></line>
  <line x1="208" y1="122" x2="216" y2="122" class="solid"></line>
  <text x="2" y="172" >addss</text>
  <text x="122" y="172" >+</text>
  <line x1="208" y1="166" x2="216" y2="166" class="solid"></line>
  <line x1="208" y1="170" x2="216" y2="170" class="solid"></line>
</svg></pre></center>
<p>With SIMD, however, all 4 array elements can be computed with a single instruction!  On x86-64, this instruction is <code>addps</code>:</p>
<center>
<pre class="svgbob"><style>text{fill:var(--fg)}</style><svg xmlns="http://www.w3.org/2000/svg" width="296" height="160">
  <style>
    line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}
    <!--separator-->
</style>
  <defs>
    <marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,0 0,4 4,2 0,0"></polygon>
    </marker>
    <marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,2 2,0 4,2 2,4 0,2"></polygon>
    </marker>
    <marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="filled"></circle>
    </marker>
    <marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="bg_filled"></circle>
    </marker>
    <marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="3" class="bg_filled"></circle>
    </marker>
  </defs>
  <rect class="backdrop" x="0" y="0" width="296" height="160"></rect>
  <text x="66" y="28" >a[0]</text>
  <text x="66" y="60" >a[1]</text>
  <text x="66" y="92" >a[2]</text>
  <text x="66" y="124" >a[3]</text>
  <text x="154" y="28" >b[0]</text>
  <text x="154" y="60" >b[1]</text>
  <text x="154" y="92" >b[2]</text>
  <text x="154" y="124" >b[3]</text>
  <text x="242" y="28" >c[0]</text>
  <text x="242" y="60" >c[1]</text>
  <text x="242" y="92" >c[2]</text>
  <text x="242" y="124" >c[3]</text>
  <text x="2" y="76" >addps</text>
  <text x="122" y="76" >+</text>
  <line x1="208" y1="70" x2="216" y2="70" class="solid"></line>
  <line x1="208" y1="74" x2="216" y2="74" class="solid"></line>
  <g>
    <path d="M 56,8 A 4,4 0,0,0 52,12" class="nofill"></path>
    <line x1="52" y1="12" x2="52" y2="132" class="solid"></line>
    <line x1="56" y1="8" x2="104" y2="8" class="solid"></line>
    <path d="M 104,8 A 4,4 0,0,1 108,12" class="nofill"></path>
    <line x1="108" y1="12" x2="108" y2="132" class="solid"></line>
    <line x1="52" y1="40" x2="108" y2="40" class="solid"></line>
    <line x1="52" y1="72" x2="108" y2="72" class="solid"></line>
    <line x1="52" y1="104" x2="108" y2="104" class="solid"></line>
    <path d="M 52,132 A 4,4 0,0,0 56,136" class="nofill"></path>
    <line x1="56" y1="136" x2="104" y2="136" class="solid"></line>
    <path d="M 108,132 A 4,4 0,0,1 104,136" class="nofill"></path>
  </g>
  <g>
    <path d="M 144,8 A 4,4 0,0,0 140,12" class="nofill"></path>
    <line x1="140" y1="12" x2="140" y2="132" class="solid"></line>
    <line x1="144" y1="8" x2="192" y2="8" class="solid"></line>
    <path d="M 192,8 A 4,4 0,0,1 196,12" class="nofill"></path>
    <line x1="196" y1="12" x2="196" y2="132" class="solid"></line>
    <line x1="140" y1="40" x2="196" y2="40" class="solid"></line>
    <line x1="140" y1="72" x2="196" y2="72" class="solid"></line>
    <line x1="140" y1="104" x2="196" y2="104" class="solid"></line>
    <path d="M 140,132 A 4,4 0,0,0 144,136" class="nofill"></path>
    <line x1="144" y1="136" x2="192" y2="136" class="solid"></line>
    <path d="M 196,132 A 4,4 0,0,1 192,136" class="nofill"></path>
  </g>
  <g>
    <path d="M 232,8 A 4,4 0,0,0 228,12" class="nofill"></path>
    <line x1="228" y1="12" x2="228" y2="132" class="solid"></line>
    <line x1="232" y1="8" x2="280" y2="8" class="solid"></line>
    <path d="M 280,8 A 4,4 0,0,1 284,12" class="nofill"></path>
    <line x1="284" y1="12" x2="284" y2="132" class="solid"></line>
    <line x1="228" y1="40" x2="284" y2="40" class="solid"></line>
    <line x1="228" y1="72" x2="284" y2="72" class="solid"></line>
    <line x1="228" y1="104" x2="284" y2="104" class="solid"></line>
    <path d="M 228,132 A 4,4 0,0,0 232,136" class="nofill"></path>
    <line x1="232" y1="136" x2="280" y2="136" class="solid"></line>
    <path d="M 284,132 A 4,4 0,0,1 280,136" class="nofill"></path>
  </g>
</svg></pre></center>
<p>SIMD operations make use of special <em>vector</em> registers to perform operations on multiple values at once.
The elements of these vectors are also known as <em>lanes</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="target-features"><a class="header" href="#target-features">Target Features</a></h1>
<p>For many architectures, SIMD support is an optional CPU feature.
Rust supports enabling a variety of these “target features”.</p>
<p>To view a list of features supported by a target, run:</p>
<pre><code>rustc --print target-features
</code></pre>
<p>To view a list of CPUs supported by a target, run:</p>
<pre><code>rustc --print target-cpus
</code></pre>
<p>This list of target features is also available in the documentation for the <a href="https://docs.rs/target-features/latest/target-features/docs/index.html"><code>target-features</code> crate</a>.</p>
<p>The following sections will address different approaches to enabling these target features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="program-wide-with-rustflags"><a class="header" href="#program-wide-with-rustflags">Program-wide with RUSTFLAGS</a></h1>
<p>Target features can be enabled program-wide by setting <code>RUSTFLAGS</code>.
The following example enables <code>avx</code> and <code>avx2</code>, and disables <code>fma</code>:</p>
<pre><code>RUSTFLAGS=&quot;-Ctarget-features=+avx,+avx2,-fma&quot; cargo build
</code></pre>
<p>Instead of targetting specific features, a particular CPU can be targeted:</p>
<pre><code>RUSTFLAGS=&quot;-Ctarget-cpu=skylake&quot; cargo build
</code></pre>
<p>Rust can also target your specific CPU, with the special <code>native</code> CPU:</p>
<pre><code>RUSTFLAGS=&quot;-Ctarget-cpu=native&quot; cargo build
</code></pre>
<div id="admonition-warning" class="admonition warning">
<div class="admonition-title">
<p>Warning</p>
<p><a class="admonition-anchor-link" href="2.1-rustflags.html#admonition-warning"></a></p>
</div>
<div>
<p>Enabling features program-wide can be dangerous!</p>
<p>If the program runs on a CPU that does not have an enabled feature, the program will crash.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-detection-of-target-features"><a class="header" href="#runtime-detection-of-target-features">Runtime detection of target features</a></h1>
<p>To safely use an optional target feature, the program must detect it at runtime.
Once a feature is detected, it can be safely used:</p>
<pre><pre class="playground"><code class="language-rust">#[target_feature(enable = &quot;avx&quot;)]
unsafe fn use_avx() {
    println!(&quot;This function uses AVX!&quot;)
}

fn main() {
    if is_x86_feature_detected!(&quot;avx&quot;) {
        unsafe { use_avx() }
    } else {
        println!(&quot;We can't use AVX.&quot;);
    }
}
</code></pre></pre>
<p>In this example, the <code>target_feature</code> attribute enables the <code>avx</code> feature.
Unlike setting the target features with <code>RUSTFLAGS</code>, this limits the features to particular functions.
The <code>is_*_feature_detected</code> macros can then be used to check if the feature is supported, and safely handle the situation where the feature is not present.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-easy-way-with-multiversion"><a class="header" href="#the-easy-way-with-multiversion">The easy way, with multiversion</a></h1>
<p>The <a href="https://crates.io/crates/multiversion"><code>multiversion</code> crate</a> is helpful for automatically <em>multiversioning</em> functions.</p>
<p>A multiversioned function is one that’s compiled multiple times for any number of targets, with the optimal function selected at runtime.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use multiversion::multiversion;

#[multiversion(targets(
    &quot;x86_64+avx&quot;,
    &quot;x86_64+sse4.2&quot;,
    &quot;arm+neon&quot;,
))]
fn multiversioned() {
    println!(&quot;This function uses whichever features are available&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p>Multiversion also supports automatically targetting all SIMD features on all architectures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use multiversion::multiversion;

#[multiversion(targets = &quot;simd&quot;)]
fn multiversioned() {
    println!(&quot;This function automatically uses the best SIMD feature available&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p>For each target, a copy of the function is compiled with the appropriate <code>target_feature</code> attributes.
At runtime, the optimal function is selected.</p>
<div id="admonition-info" class="admonition info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="2.3-multiversion.html#admonition-info"></a></p>
</div>
<div>
<p>Compared to the example on the previous page, <code>multiversion</code> also selects the appropriate function with less performance overhead.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="portable-simd"><a class="header" href="#portable-simd">Portable SIMD</a></h1>
<p>Rust provides a “portable” SIMD implementation, available in the <a href="https://doc.rust-lang.org/std/simd/index.html"><code>std::simd</code> module</a>.</p>
<h2 id="what-is-portable"><a class="header" href="#what-is-portable">What is “portable”?</a></h2>
<p>Compilers, including the Rust compiler, often implement SIMD in a few different ways.
To understand what “portable” means, let’s explore the different implementations.</p>
<h3 id="automatic-vectorization"><a class="header" href="#automatic-vectorization">Automatic Vectorization</a></h3>
<p>One way that Rust makes use of SIMD is by an optimization called automatic vectorization.
Instead of using any special SIMD support in the Rust language, the compiler tries to identify regular Rust code that it can turn into SIMD operations.</p>
<p>This is a convenient optimization because the programmer doesn’t need to do anything special to their code.
The downside is that the optimization only works in specific circumstances, since the compiler must be able to determine that it can split up a particular bit of code to run in parallel.</p>
<h3 id="vendor-intrinsics"><a class="header" href="#vendor-intrinsics">Vendor Intrinsics</a></h3>
<p>Hardware vendors provide special functions called <em>intrinsics</em> which correspond to particular instructions or behavior.
In Rust, these are provded by the <a href="https://doc.rust-lang.org/std/arch/index.html"><code>std::arch</code> module</a>.</p>
<p>Using vendor intrinsics is a form of <em>explicit SIMD</em>, in which the programmer specifies exactly how the program is parallelized.
Vendor intrinsics also provide complete access to features available to a particular target architecture, offering the best potential for performance.
This capability comes at the cost of portability: code that uses vendor intrinsics will only work with that particular target.</p>
<p>More information about using vendor intrinsics is found in the next section.</p>
<h3 id="portable-simd-1"><a class="header" href="#portable-simd-1">Portable SIMD</a></h3>
<p>Rust’s portable SIMD implementation offers a middle ground between automatic vectorization and vendor intrinsics.</p>
<p>Portable SIMD is another form of <em>explicit SIMD</em> and allows the programmer to specify how the program is parallelized.
Unlike vendor intrinsics, portable SIMD works on all targets.
Rust’s portable SIMD vector types provide the most common SIMD operations that perform well on most SIMD instruction sets.</p>
<p>In many cases, using portable SIMD can result in similar or identical compiled programs as the equivalent code using vendor intrinsics.
With portable SIMD, programmers have the ability to write intricate vectorized programs and be confident that their code will not just perform well, but will also act as expected on any target architecture.
Reaching for vendor intrinsics is often only necessary when taking advantage of an unusual feature provided by a specific target.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectors"><a class="header" href="#vectors">Vectors</a></h1>
<p>Rust provides portable SIMD vectors with the <a href="https://doc.rust-lang.org/std/simd/struct.Simd.html"><code>Simd</code> type</a>.</p>
<p><code>Simd&lt;T, N&gt;</code> can be thought of as a variation on <code>[T; N]</code>.
<code>Simd</code> has the same layout as an array, but with a greater alignment.
In fact, <code>Simd&lt;T, N&gt;</code> is easily convertible to and from <code>[T; N]</code>, and supports some of the same operations, such as indexing.</p>
<h2 id="elementwise-operations-on-vectors"><a class="header" href="#elementwise-operations-on-vectors">Elementwise operations on vectors</a></h2>
<p>Unlike arrays, <code>Simd&lt;T, N&gt;</code> is not just a container.
While it looks like an array, it also operates like <code>T</code>.
Vectors implement all of the same basic operators as its scalar type <code>T</code>, meaning you can do the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::simd::f32x4; // an alias for Simd&lt;f32, 4&gt;

/// y = mx + b
fn y(m: f32x4, x: f32x4, b: f32x4) -&gt; f32x4 {
    m * x + b
}
<span class="boring">}
</span></code></pre></pre>
<p>These operators work <em>elementwise</em>, meaning the operator is applied one element at a time.</p>
<p>Vectors even implement special functions (e.g. <code>abs</code>) with special traits:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::simd::{f32x4, SimdFloat}; // SimdFloat provides abs

/// |a - b|
fn distance(a: f32x4, b: f32x4) -&gt; f32x4 {
    (a - b).abs()
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="reduction-operations"><a class="header" href="#reduction-operations">Reduction operations</a></h2>
<p>Sometimes you may want to perform an operation across a single vector, rather than between vectors.
These operations are referred to as <em>reductions</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::simd::{f32x4, SimdFloat}; // SimdFloat provides reduce_sum

fn sum(vectors: &amp;[f32x4]) -&gt; f32 {
    let mut sums = f32x4::splat(0.0); // splat fills each element with the value
    for v in vectors {
        sums += v;
    }
    
    // `sums` now contains the elementwise sums, so we must sum across the vector
    sums.reduce_sum()
}
<span class="boring">}
</span></code></pre></pre>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="3.1-vectors.html#admonition-note"></a></p>
</div>
<div>
<p>Reductions are slower than elementwise operations in most cases.
It’s best to use elementwise operations when possible, and use reductions only when necessary.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="masks"><a class="header" href="#masks">Masks</a></h1>
<p>Rust also provides a “truthy” vector type: <a href="https://doc.rust-lang.org/std/simd/struct.Mask.html"><code>Mask&lt;T, N&gt;</code></a>.</p>
<p>While operating like <code>bool</code>, the element type of a mask is always a signed integer.
The size of the integer corresponds to the vector elements that the mask can interact with.</p>
<p>Masks operate like <code>[bool; N]</code>, but their layout is unspecified and target-specific.</p>
<h2 id="elementwise-operations-with-masks"><a class="header" href="#elementwise-operations-with-masks">Elementwise operations with masks</a></h2>
<p>Masks are typically prodced by comparisons.
Like vectors, they also support elementwise operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// m32x4 is an alias for Mask&lt;i32, 4&gt;
//
// SimdPartialOrd is the elementwise counterpart to PartialOrd,
// and provides `simd_lt`, `simd_gt`, etc.
use std::simd::{f32x4, m32x4, SimdPartialOrd};

fn is_between(x: f32x4, lower_bound: f32x4, upper_bound: f32x4) -&gt; m32x4 {
    let above_lower_bound: m32x4 = x.simd_gt(lower_bound);
    let below_upper_bound: m32x4 = x.simd_lt(upper_bound);
    above_lower_bound &amp; below_upper_bound
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="reduction-operations-1"><a class="header" href="#reduction-operations-1">Reduction operations</a></h2>
<p>Masks also support reduction operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::simd::{f32x4, m32x4, SimdFloat}; // SimdFloat provides is_infinite

fn any_infinite(vectors: &amp;[f32x4]) -&gt; bool {
    let mut any_infinite = m32x4::splat(false);
    for v in vectors {
        infinite |= v.is_infinite();
    }
    
    // check if any element is `true`
    infinite.any()
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="conditionally-selecting-elements"><a class="header" href="#conditionally-selecting-elements">Conditionally selecting elements</a></h2>
<p>Masks can be used to conditionally select elements from two vectors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::simd::{f32x4, m32x4, SimdFloat}; // SimdFloat provides is_nan

/// replace nan values with 0
fn replace_nan(x: f32x4) -&gt; f32x4 {
    let nans: m32x4 = x.is_nan();
    nans.select(f32x4::splat(0.0), x)
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="explicit-simd-stdarch"><a class="header" href="#explicit-simd-stdarch">Explicit SIMD (std::arch)</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
