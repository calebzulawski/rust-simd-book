<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Portable SIMD Programming in Rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mdbook-admonish.css">
        <link rel="stylesheet" href="././mdbook-admonish.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="0-title.html">Portable SIMD Programming in Rust</a></li><li class="chapter-item expanded "><a href="1-intro.html"><strong aria-hidden="true">1.</strong> A quick introduction</a></li><li class="chapter-item expanded "><a href="2-portable-simd.html"><strong aria-hidden="true">2.</strong> Portable SIMD</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2.1-vectors.html"><strong aria-hidden="true">2.1.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="2.2-masks.html"><strong aria-hidden="true">2.2.</strong> Masks</a></li><li class="chapter-item expanded "><a href="2.3-vendor-intrinsics.html"><strong aria-hidden="true">2.3.</strong> Vendor Intrinsics</a></li></ol></li><li class="chapter-item expanded "><a href="3-target-features.html"><strong aria-hidden="true">3.</strong> Target Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.1-rustflags.html"><strong aria-hidden="true">3.1.</strong> Program-wide with RUSTFLAGS</a></li><li class="chapter-item expanded "><a href="3.2-detection.html"><strong aria-hidden="true">3.2.</strong> Runtime detection</a></li><li class="chapter-item expanded "><a href="3.3-multiversion.html"><strong aria-hidden="true">3.3.</strong> The easy way, with multiversion</a></li></ol></li><li class="chapter-item expanded "><a href="4-tricks.html"><strong aria-hidden="true">4.</strong> Tips and tricks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4.1-inlining.html"><strong aria-hidden="true">4.1.</strong> Inlining and target features</a></li><li class="chapter-item expanded "><a href="4.2-native-vector-width.html"><strong aria-hidden="true">4.2.</strong> Native vector width</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Portable SIMD Programming in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="portable-simd-programming-in-rust"><a class="header" href="#portable-simd-programming-in-rust">Portable SIMD Programming in Rust</a></h1>
<p>by Caleb Zulawski</p>
<p>Rust’s portable SIMD module enables users to write high performace code without wading into the arcane details of instruction sets.</p>
<p>This book is intended for anyone who is familiar with Rust and curious about SIMD.
A few types of people who might benefit from reading this:</p>
<ul>
<li>Someone who has never used SIMD but is interested in speeding up their code’s arithmetic</li>
<li>A programmer looking to simplify a codebase with target-specific SIMD code</li>
<li>An experienced SIMD programmer who wants to branch out to other target architectures</li>
<li>Someone already familiar with portable SIMD who wants to fill out their knowledge</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-quick-introduction"><a class="header" href="#a-quick-introduction">A quick introduction</a></h1>
<p>SIMD is short for <em>single instruction, multiple data</em>.
As the name suggests, a single SIMD instruction can operate on multiple data values simultaneously.
This type of parallelism can speed up programs, and comes with much lower overhead and complexity than other types of parallelism, such as concurrency.</p>
<p>Consider the following function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_array(a: [f32; 4], b: [f32; 4]) -&gt; [f32; 4] {
    [
        a[0] + b[0],
        a[1] + b[1],
        a[2] + b[2],
        a[3] + b[3],
    ]
}
<span class="boring">}
</span></code></pre></pre>
<p>Without SIMD, each array element is computed separately.  On x86-64, this instruction is <code>addss</code>:</p>
<center>
<pre class="svgbob"><style>text{fill:var(--fg)}</style><svg xmlns="http://www.w3.org/2000/svg" width="296" height="208">
  <style>
    line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}
    <!--separator-->
</style>
  <defs>
    <marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,0 0,4 4,2 0,0"></polygon>
    </marker>
    <marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,2 2,0 4,2 2,4 0,2"></polygon>
    </marker>
    <marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="filled"></circle>
    </marker>
    <marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="bg_filled"></circle>
    </marker>
    <marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="3" class="bg_filled"></circle>
    </marker>
  </defs>
  <rect class="backdrop" x="0" y="0" width="296" height="208"></rect>
  <rect x="52" y="8" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="66" y="28" >a[0]</text>
  <rect x="52" y="56" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="66" y="76" >a[1]</text>
  <rect x="52" y="104" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="66" y="124" >a[2]</text>
  <rect x="52" y="152" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="66" y="172" >a[3]</text>
  <rect x="140" y="8" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="154" y="28" >b[0]</text>
  <rect x="140" y="56" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="154" y="76" >b[1]</text>
  <rect x="140" y="104" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="154" y="124" >b[2]</text>
  <rect x="140" y="152" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="154" y="172" >b[3]</text>
  <rect x="228" y="8" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="242" y="28" >c[0]</text>
  <rect x="228" y="56" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="242" y="76" >c[1]</text>
  <rect x="228" y="104" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="242" y="124" >c[2]</text>
  <rect x="228" y="152" width="56" height="32" class="solid nofill" rx="4"></rect>
  <text x="242" y="172" >c[3]</text>
  <text x="2" y="28" >addss</text>
  <text x="122" y="28" >+</text>
  <line x1="208" y1="22" x2="216" y2="22" class="solid"></line>
  <line x1="208" y1="26" x2="216" y2="26" class="solid"></line>
  <text x="2" y="76" >addss</text>
  <text x="122" y="76" >+</text>
  <line x1="208" y1="70" x2="216" y2="70" class="solid"></line>
  <line x1="208" y1="74" x2="216" y2="74" class="solid"></line>
  <text x="2" y="124" >addss</text>
  <text x="122" y="124" >+</text>
  <line x1="208" y1="118" x2="216" y2="118" class="solid"></line>
  <line x1="208" y1="122" x2="216" y2="122" class="solid"></line>
  <text x="2" y="172" >addss</text>
  <text x="122" y="172" >+</text>
  <line x1="208" y1="166" x2="216" y2="166" class="solid"></line>
  <line x1="208" y1="170" x2="216" y2="170" class="solid"></line>
</svg></pre></center>
<p>With SIMD, however, all 4 array elements can be computed with a single instruction!  On x86-64, this instruction is <code>addps</code>:</p>
<center>
<pre class="svgbob"><style>text{fill:var(--fg)}</style><svg xmlns="http://www.w3.org/2000/svg" width="296" height="160">
  <style>
    line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}
    <!--separator-->
</style>
  <defs>
    <marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,0 0,4 4,2 0,0"></polygon>
    </marker>
    <marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,2 2,0 4,2 2,4 0,2"></polygon>
    </marker>
    <marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="filled"></circle>
    </marker>
    <marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="bg_filled"></circle>
    </marker>
    <marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="3" class="bg_filled"></circle>
    </marker>
  </defs>
  <rect class="backdrop" x="0" y="0" width="296" height="160"></rect>
  <text x="66" y="28" >a[0]</text>
  <text x="66" y="60" >a[1]</text>
  <text x="66" y="92" >a[2]</text>
  <text x="66" y="124" >a[3]</text>
  <text x="154" y="28" >b[0]</text>
  <text x="154" y="60" >b[1]</text>
  <text x="154" y="92" >b[2]</text>
  <text x="154" y="124" >b[3]</text>
  <text x="242" y="28" >c[0]</text>
  <text x="242" y="60" >c[1]</text>
  <text x="242" y="92" >c[2]</text>
  <text x="242" y="124" >c[3]</text>
  <text x="2" y="76" >addps</text>
  <text x="122" y="76" >+</text>
  <line x1="208" y1="70" x2="216" y2="70" class="solid"></line>
  <line x1="208" y1="74" x2="216" y2="74" class="solid"></line>
  <g>
    <path d="M 56,8 A 4,4 0,0,0 52,12" class="nofill"></path>
    <line x1="52" y1="12" x2="52" y2="132" class="solid"></line>
    <line x1="56" y1="8" x2="104" y2="8" class="solid"></line>
    <path d="M 104,8 A 4,4 0,0,1 108,12" class="nofill"></path>
    <line x1="108" y1="12" x2="108" y2="132" class="solid"></line>
    <line x1="52" y1="40" x2="108" y2="40" class="solid"></line>
    <line x1="52" y1="72" x2="108" y2="72" class="solid"></line>
    <line x1="52" y1="104" x2="108" y2="104" class="solid"></line>
    <path d="M 52,132 A 4,4 0,0,0 56,136" class="nofill"></path>
    <line x1="56" y1="136" x2="104" y2="136" class="solid"></line>
    <path d="M 108,132 A 4,4 0,0,1 104,136" class="nofill"></path>
  </g>
  <g>
    <path d="M 144,8 A 4,4 0,0,0 140,12" class="nofill"></path>
    <line x1="140" y1="12" x2="140" y2="132" class="solid"></line>
    <line x1="144" y1="8" x2="192" y2="8" class="solid"></line>
    <path d="M 192,8 A 4,4 0,0,1 196,12" class="nofill"></path>
    <line x1="196" y1="12" x2="196" y2="132" class="solid"></line>
    <line x1="140" y1="40" x2="196" y2="40" class="solid"></line>
    <line x1="140" y1="72" x2="196" y2="72" class="solid"></line>
    <line x1="140" y1="104" x2="196" y2="104" class="solid"></line>
    <path d="M 140,132 A 4,4 0,0,0 144,136" class="nofill"></path>
    <line x1="144" y1="136" x2="192" y2="136" class="solid"></line>
    <path d="M 196,132 A 4,4 0,0,1 192,136" class="nofill"></path>
  </g>
  <g>
    <path d="M 232,8 A 4,4 0,0,0 228,12" class="nofill"></path>
    <line x1="228" y1="12" x2="228" y2="132" class="solid"></line>
    <line x1="232" y1="8" x2="280" y2="8" class="solid"></line>
    <path d="M 280,8 A 4,4 0,0,1 284,12" class="nofill"></path>
    <line x1="284" y1="12" x2="284" y2="132" class="solid"></line>
    <line x1="228" y1="40" x2="284" y2="40" class="solid"></line>
    <line x1="228" y1="72" x2="284" y2="72" class="solid"></line>
    <line x1="228" y1="104" x2="284" y2="104" class="solid"></line>
    <path d="M 228,132 A 4,4 0,0,0 232,136" class="nofill"></path>
    <line x1="232" y1="136" x2="280" y2="136" class="solid"></line>
    <path d="M 284,132 A 4,4 0,0,1 280,136" class="nofill"></path>
  </g>
</svg></pre></center>
<p>SIMD operations make use of special <em>vector</em> registers to perform operations on multiple values at once.
The elements of these vectors are also known as <em>lanes</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="portable-simd"><a class="header" href="#portable-simd">Portable SIMD</a></h1>
<p>Rust provides a “portable” SIMD implementation, available in the <a href="https://doc.rust-lang.org/std/simd/index.html"><code>std::simd</code> module</a>.</p>
<h2 id="what-is-portable"><a class="header" href="#what-is-portable">What is “portable”?</a></h2>
<p>Compilers, including the Rust compiler, often implement SIMD in a few different ways.
To understand what “portable” means, let’s explore the different implementations.</p>
<h3 id="automatic-vectorization"><a class="header" href="#automatic-vectorization">Automatic Vectorization</a></h3>
<p>One way that Rust makes use of SIMD is by an optimization called automatic vectorization.
Instead of using any special SIMD support in the Rust language, the compiler tries to identify regular Rust code that it can turn into SIMD operations.</p>
<p>This is a convenient optimization because the programmer doesn’t need to do anything special to their code.
The downside is that the optimization only works in specific circumstances, since the compiler must be able to determine that it can split up a particular bit of code to run in parallel.</p>
<h3 id="vendor-intrinsics"><a class="header" href="#vendor-intrinsics">Vendor Intrinsics</a></h3>
<p>Hardware vendors provide special functions called <em>intrinsics</em> which correspond to particular instructions or behavior.
In Rust, these are provided by the <a href="https://doc.rust-lang.org/std/arch/index.html"><code>std::arch</code> module</a>.</p>
<p>Using vendor intrinsics is a form of <em>explicit SIMD</em>, in which the programmer specifies exactly how the program is parallelized.
Vendor intrinsics also provide complete access to features available to a particular target architecture, offering the best potential for performance.
This capability comes at the cost of portability: code that uses vendor intrinsics will only work on that particular target.</p>
<h3 id="portable-simd-1"><a class="header" href="#portable-simd-1">Portable SIMD</a></h3>
<p>Rust’s portable SIMD implementation offers a middle ground between automatic vectorization and vendor intrinsics.</p>
<p>Portable SIMD is another form of <em>explicit SIMD</em> and allows the programmer to specify how the program is parallelized.
Unlike vendor intrinsics, portable SIMD works on all targets.
Rust’s portable SIMD vector types provide the most common SIMD operations that perform well on most SIMD instruction sets.</p>
<p>In many cases, using portable SIMD can result in similar or identical compiled programs as the equivalent code using vendor intrinsics.
With portable SIMD, programmers have the ability to write intricate vectorized programs and be confident that their code will not just perform well, but will also act as expected on any target architecture.
Reaching for vendor intrinsics is often only necessary when taking advantage of an unusual feature provided by a specific target.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectors"><a class="header" href="#vectors">Vectors</a></h1>
<p>Rust provides portable SIMD vectors with the <a href="https://doc.rust-lang.org/std/simd/struct.Simd.html"><code>Simd</code> type</a>.</p>
<p><code>Simd&lt;T, N&gt;</code> can be thought of as a variation on <code>[T; N]</code>.
<code>Simd</code> has the same layout as an array, but with a greater alignment.
In fact, <code>Simd&lt;T, N&gt;</code> is easily convertible to and from <code>[T; N]</code>, and supports some of the same operations, such as indexing.</p>
<h2 id="elementwise-operations-on-vectors"><a class="header" href="#elementwise-operations-on-vectors">Elementwise operations on vectors</a></h2>
<p>Unlike arrays, <code>Simd&lt;T, N&gt;</code> is not just a container.
While it looks like an array, it also operates like <code>T</code>.
Vectors implement all of the same basic operators as its scalar type <code>T</code>, meaning you can do the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![feature(portable_simd)]
</span><span class="boring">fn main() {}
</span>use std::simd::f32x4; // an alias for Simd&lt;f32, 4&gt;

/// y = mx + b
fn y(m: f32x4, x: f32x4, b: f32x4) -&gt; f32x4 {
    m * x + b
}
</code></pre></pre>
<p>These operators work <em>elementwise</em>, meaning the operator is applied to each element separately.</p>
<p>Vectors even implement special functions (e.g. <code>abs</code>) with special traits:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![feature(portable_simd)]
</span><span class="boring">fn main() {}
</span>use std::simd::{f32x4, SimdFloat}; // SimdFloat provides abs

/// |a - b|
fn distance(a: f32x4, b: f32x4) -&gt; f32x4 {
    (a - b).abs()
}
</code></pre></pre>
<h2 id="reduction-operations"><a class="header" href="#reduction-operations">Reduction operations</a></h2>
<p>Sometimes you may want to perform an operation across a single vector, rather than between vectors.
These operations are referred to as <em>reductions</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![feature(portable_simd)]
</span><span class="boring">fn main() {}
</span>use std::simd::{f32x4, SimdFloat}; // SimdFloat provides reduce_sum

fn sum(vectors: &amp;[f32x4]) -&gt; f32 {
    let mut sums = f32x4::splat(0.0); // splat fills each element with the value
    for v in vectors {
        sums += v;
    }
    
    // `sums` now contains the elementwise sums, so we must sum across the vector
    sums.reduce_sum()
}
</code></pre></pre>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="2.1-vectors.html#admonition-note"></a></p>
</div>
<div>
<p>Reductions are slower than elementwise operations in most cases.
It’s best to use elementwise operations when possible, and use reductions only when necessary.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="masks"><a class="header" href="#masks">Masks</a></h1>
<p>Rust also provides a “truthy” vector type: <a href="https://doc.rust-lang.org/std/simd/struct.Mask.html"><code>Mask&lt;T, N&gt;</code></a>.</p>
<p>While operating like <code>bool</code>, the element type of a mask is always a signed integer.
The size of the integer corresponds to the vector elements that the mask can interact with.</p>
<p>Masks operate like <code>[bool; N]</code>, but their layout is unspecified and target-specific.</p>
<h2 id="elementwise-operations-with-masks"><a class="header" href="#elementwise-operations-with-masks">Elementwise operations with masks</a></h2>
<p>Masks are typically produced by comparisons.
Like vectors, they also support elementwise operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![feature(portable_simd)]
</span><span class="boring">fn main() {}
</span>// mask32x4 is an alias for Mask&lt;i32, 4&gt;
//
// SimdPartialOrd is the elementwise counterpart to PartialOrd,
// and provides `simd_lt`, `simd_gt`, etc.
use std::simd::{f32x4, mask32x4, SimdPartialOrd};

fn is_between(x: f32x4, lower_bound: f32x4, upper_bound: f32x4) -&gt; mask32x4 {
    let above_lower_bound: mask32x4 = x.simd_gt(lower_bound);
    let below_upper_bound: mask32x4 = x.simd_lt(upper_bound);
    above_lower_bound &amp; below_upper_bound
}
</code></pre></pre>
<h2 id="reduction-operations-1"><a class="header" href="#reduction-operations-1">Reduction operations</a></h2>
<p>Masks also support reduction operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![feature(portable_simd)]
</span><span class="boring">fn main() {}
</span>use std::simd::{f32x4, mask32x4, SimdFloat}; // SimdFloat provides is_infinite

fn any_infinite(vectors: &amp;[f32x4]) -&gt; bool {
    let mut infinite = mask32x4::splat(false);
    for v in vectors {
        infinite |= v.is_infinite();
    }
    
    // check if any element is `true`
    infinite.any()
}
</code></pre></pre>
<h2 id="conditionally-selecting-elements"><a class="header" href="#conditionally-selecting-elements">Conditionally selecting elements</a></h2>
<p>Masks can be used to conditionally select elements from two vectors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![feature(portable_simd)]
</span><span class="boring">fn main() {}
</span>use std::simd::{f32x4, mask32x4, SimdFloat}; // SimdFloat provides is_nan

/// replace nan values with 0
fn replace_nan(x: f32x4) -&gt; f32x4 {
    let nans: mask32x4 = x.is_nan();
    nans.select(f32x4::splat(0.0), x)
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vendor-intrinsics-1"><a class="header" href="#vendor-intrinsics-1">Vendor Intrinsics</a></h1>
<p>Sometimes you can’t avoid using vendor intrinsics.
In those cases, it’s easy to convert between vendor vector types and portable SIMD vector types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![feature(portable_simd)]
</span><span class="boring">fn main() {}
</span>use std::arch::x86_64::{_mm_stream_ps, __m128};
use std::simd::f32x4;

unsafe fn non_temporal_store(addr: *mut f32, vector: f32x4) {
    let vendor: __m128 = vector.into(); // convert into the vendor type
    _mm_stream_ps(addr, vendor);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="target-features"><a class="header" href="#target-features">Target Features</a></h1>
<p>For many architectures, SIMD support is an optional CPU feature.
Rust supports enabling a variety of these “target features”.</p>
<p>To view a list of features supported by a target, run:</p>
<pre><code class="language-bash">rustc --print target-features
</code></pre>
<p>To view a list of CPUs supported by a target, run:</p>
<pre><code class="language-bash">rustc --print target-cpus
</code></pre>
<p>This list of target features is also available in the documentation for the <a href="https://docs.rs/target-features/latest/target_features/docs/index.html"><code>target-features</code> crate</a>.</p>
<p>The following sections will address different approaches to enabling these target features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="program-wide-with-rustflags"><a class="header" href="#program-wide-with-rustflags">Program-wide with RUSTFLAGS</a></h1>
<p>Target features can be enabled program-wide by setting <code>RUSTFLAGS</code>.
The following example enables <code>avx</code> and <code>avx2</code>, and disables <code>fma</code>:</p>
<pre><code class="language-bash">RUSTFLAGS=&quot;-Ctarget-features=+avx,+avx2,-fma&quot; cargo build
</code></pre>
<p>Instead of targetting specific features, a particular CPU can be targeted:</p>
<pre><code class="language-bash">RUSTFLAGS=&quot;-Ctarget-cpu=skylake&quot; cargo build
</code></pre>
<p>Rust can also target your specific CPU, with the special <code>native</code> CPU:</p>
<pre><code class="language-bash">RUSTFLAGS=&quot;-Ctarget-cpu=native&quot; cargo build
</code></pre>
<div id="admonition-warning" class="admonition warning">
<div class="admonition-title">
<p>Warning</p>
<p><a class="admonition-anchor-link" href="3.1-rustflags.html#admonition-warning"></a></p>
</div>
<div>
<p>Enabling features program-wide can be dangerous!</p>
<p>If the program runs on a CPU that does not have an enabled feature, the program will crash.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-detection-of-target-features"><a class="header" href="#runtime-detection-of-target-features">Runtime detection of target features</a></h1>
<p>To safely use an optional target feature, the program must detect it at runtime.
Once a feature is detected, it can be safely used:</p>
<pre><pre class="playground"><code class="language-rust">#[target_feature(enable = &quot;avx&quot;)]
unsafe fn use_avx() {
    println!(&quot;This function uses AVX!&quot;)
}

fn main() {
    if is_x86_feature_detected!(&quot;avx&quot;) {
        unsafe { use_avx() }
    } else {
        println!(&quot;We can't use AVX.&quot;);
    }
}
</code></pre></pre>
<p>In this example, the <code>target_feature</code> attribute enables the <code>avx</code> feature.
Unlike setting the target features with <code>RUSTFLAGS</code>, this limits the features to particular functions.
The <code>is_*_feature_detected</code> macros can then be used to check if the feature is supported, and safely handle the situation where the feature is not present.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-easy-way-with-multiversion"><a class="header" href="#the-easy-way-with-multiversion">The easy way, with multiversion</a></h1>
<p>The <a href="https://crates.io/crates/multiversion"><code>multiversion</code> crate</a> is helpful for automatically <em>multiversioning</em> functions.</p>
<p>A multiversioned function is one that’s compiled multiple times for any number of targets, with the optimal function selected at runtime.</p>
<pre><code class="language-rust ignore">use multiversion::multiversion;

#[multiversion(targets(
    &quot;x86_64+avx&quot;,
    &quot;x86_64+sse4.2&quot;,
    &quot;arm+neon&quot;,
))]
fn multiversioned() {
    println!(&quot;This function uses whichever features are available&quot;)
}
</code></pre>
<p>Multiversion also supports automatically targetting all SIMD features on all architectures:</p>
<pre><code class="language-rust ignore">use multiversion::multiversion;

#[multiversion(targets = &quot;simd&quot;)]
fn multiversioned() {
    println!(&quot;This function automatically uses the best SIMD feature available&quot;)
}
</code></pre>
<p>For each target, a copy of the function is compiled with the appropriate <code>target_feature</code> attributes.
At runtime, the optimal function is selected.</p>
<div id="admonition-info" class="admonition info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="3.3-multiversion.html#admonition-info"></a></p>
</div>
<div>
<p>Compared to the example on the previous page, <code>multiversion</code> also selects the appropriate function with less performance overhead.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tips-and-tricks"><a class="header" href="#tips-and-tricks">Tips and tricks</a></h1>
<p>Portable SIMD is intended to be an accessible yet powerful tool.
There are a few common pitfalls that can affect the speed of your code.
This section will address those pitfalls and provide some recommendations on how to avoid them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inlining-and-target-features"><a class="header" href="#inlining-and-target-features">Inlining and target features</a></h1>
<p>Inlining and target features have a few interactions that can significantly affect the speed of your program.</p>
<h2 id="target_feature-hinders-inlining"><a class="header" href="#target_feature-hinders-inlining"><code>#[target_feature]</code> hinders inlining</a></h2>
<p>Modern CPUs often use <em>speculative execution</em>, where instructions following a branch (e.g. <code>if</code>) are executed before knowing the result.
Once the branch path is known, the correct result is used.</p>
<p>Consider the following example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[target_feature(enable = &quot;avx&quot;)]
unsafe fn avx_fn() {
    println!(&quot;This function uses AVX.&quot;)
}

if is_x86_feature_detected!(&quot;avx&quot;) {
    unsafe { avx_fn() }
}
<span class="boring">}
</span></code></pre></pre>
<p>If speculative execution was used with this branch, the CPU might try to execute an AVX instruction before knowing if it even supports it, potentially crashing the program.
Fortunately, speculative execution stops at function calls, so <code>#[target_feature]</code> avoids this by also preventing inlining.</p>
<p>Since non-inlined function calls can be slow, try to use one large function tagged with <code>#[target_feature]</code>, rather than many separate functions.
Additionally, multiple uses of <code>#[target_feature]</code> may not be necessary, as explained in the next paragraph.</p>
<div id="admonition-info" class="admonition info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="4.1-inlining.html#admonition-info"></a></p>
</div>
<div>
<p>Functions with <code>#[target_feature]</code> can still inline into other functions that support the same features via <code>#[target_feature]</code> or the <code>-Ctarget-feature</code> flag.</p>
</div>
</div>
<h2 id="inlined-functions-can-inherit-target-features"><a class="header" href="#inlined-functions-can-inherit-target-features">Inlined functions can inherit target features</a></h2>
<p>When a function is inlined into another function tagged with <code>#[target_feature]</code>, the inlined function is also compiled with those target features.
To help ensure inlining, the <code>#[inline]</code> attribute can be used.
This behavior can be used to write functions without worrying about what the final target features will be—in fact, this is what portable SIMD does!
Functions in <code>std::simd</code> are inlined, allowing the user to specify the target features.</p>
<p>In the following example, all of the code is generated using AVX, because it’s all inlined into the function with <code>#[target_feature]</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![feature(portable_simd)]
</span><span class="boring">fn main() {}
</span>use std::simd::f32x4;

#[inline]
fn double(x: f32x4) -&gt; f32x4 {
    x * f32x4::splat(2.0) // The `splat` and `*` functions are inlined here
}

#[target_feature(enable = &quot;avx&quot;)]
unsafe fn double_avx(x: f32x4) -&gt; f32x4 {
    double(x) // The `double` function is inlined here
}
</code></pre></pre>
<h2 id="target-features-affect-calling-convention"><a class="header" href="#target-features-affect-calling-convention">Target features affect calling convention</a></h2>
<p>The target features of a function affect its <em>calling convention</em>, the way memory is arranged when calling the function.
Specifically, the target features affect which vector registers are used to pass vectors.</p>
<p>To ensure that functions with different target features can still be used in the same program, Rust passes vectors by reference instead of by value.
This can significantly slow down calling functions with vector arguments because it forces the vector to be written to memory.</p>
<p>To avoid this behavior, avoid using vectors as arguments in non-inlined functions.
Inlined functions are not affected because the function call is optimized out.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="native-vector-width"><a class="header" href="#native-vector-width">Native vector width</a></h1>
<p>Different architectures have different vector register sizes.
To make it even more complicated, some architectures have different vector register sizes available depending on target features and element type.</p>
<h2 id="using-a-fixed-vector-size"><a class="header" href="#using-a-fixed-vector-size">Using a fixed vector size</a></h2>
<p>Some algorithms might be better suited to particular vector sizes, even if it doesn’t match the native vector size.
In the case of mismatched sizes, there are two possibilities:</p>
<ul>
<li>If the vectors are smaller than the native vector registers, native vectors will still be used but will be partially empty.
In this scenario, the full parallel capability of the target is underused.</li>
<li>If the vectors are larger than the native vector registers, multiple native vectors will be used to emulate one large vector.
If too many native vectors are used, the program can <em>spill</em>, meaning it has run out of registers and must use (much slower) memory instead.</li>
</ul>
<p>Using a fixed vector size is a tradeoff between these possible issues and the design of the particular algorithm.</p>
<h2 id="using-the-native-vector-size"><a class="header" href="#using-the-native-vector-size">Using the native vector size</a></h2>
<p>The <code>target-features</code> crate provides a function for determining the native vector size:</p>
<pre><code class="language-rust ignore">use target_features::CURRENT_TARGET;

// Different element types can have different vector sizes. Here we use `f32`.
const N: usize = if let Some(size) = CURRENT_TARGET.suggested_vector_width::&lt;f32&gt;() {
    size
} else {
    // If SIMD isn't supported natively, we use a vector of 1 element.
    // This is effectively a scalar value.
    1
};

/// Now we can use `Vector` instead of a particular vector type.
type Vector = Simd&lt;f32, N&gt;;
</code></pre>
<p>When detecting features, the <code>multiversion</code> crate provides the same capability:</p>
<pre><code class="language-rust ignore">use multiversion::{multiversion, target::selected_target};

#[multiversion(targets = &quot;simd&quot;)]
fn example() {
    // The `selected_target` macro takes into account the detected optional features,
    // and not just the base features used in the previous example.
    const N: usize = if let Some(size) = selected_target!().suggested_vector_width::&lt;f32&gt;() {
        size
    } else {
        1
    };

    /// Once again, we can use `Vector` instead of a particular vector type.
    type Vector = Simd&lt;f32, N&gt;;
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
